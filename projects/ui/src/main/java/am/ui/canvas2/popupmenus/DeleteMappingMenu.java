package am.ui.canvas2.popupmenus;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;

import am.app.Core;
import am.app.lexicon.Lexicon;
import am.app.mappingEngine.AbstractMatcher;
import am.app.mappingEngine.AbstractMatcher.alignType;
import am.app.mappingEngine.LexiconStore.LexiconRegistry;
import am.app.mappingEngine.Mapping;
import am.app.mappingEngine.MatchingTask;
import am.app.ontology.Node;
import am.app.ontology.Ontology;
import am.tools.LexiconLookup.LexiconLookupPanel;
import am.ui.UICore;
import am.ui.UIUtility;
import am.ui.canvas2.Canvas2;
import am.ui.canvas2.graphical.MappingData;
import am.ui.canvas2.graphical.MappingData.MappingType;
import am.ui.canvas2.nodes.LegacyMapping;
import am.ui.canvas2.utility.Canvas2Layout;
import am.ui.canvas2.utility.Canvas2Vertex;
import am.ui.canvas2.utility.CanvasGraph;

public class DeleteMappingMenu extends JPopupMenu implements ActionListener {

	private static final long serialVersionUID = 3231794310838624406L;
	private ArrayList<LegacyMapping> mappings;

	private static final int provenanceStringMaxLength = 50;
	private static final String DELETE = "DELETE_";
	private static final String SET_PROVENANCE = "SET_PROVENANCE_";
	
	Canvas2Layout layout;
	Canvas2Vertex node; // the node that we right clicked.
	
	public DeleteMappingMenu( Canvas2Layout lay, Canvas2Vertex hoveringOver, ArrayList<LegacyMapping> m ) {
		super();
		
		layout = lay;
		mappings = m;
		node = hoveringOver;
		
		// menu layout - Jan 29, 2010 Cosmin
		//  1. Delete Mappings (selected matchers) (item)
		//  2. Delete Individual Mappings   (menu)  TODO
		//     <autogenerated menu>
		//  --------------------
		//  3. View Lexicon entry
		//  3. Delete All Mappings (item)
		
		JMenu mDeleteMappings = new JMenu("Delete Mappings");
		JMenu mProvenance = new JMenu("Set mapping provenance");
		JMenuItem miViewLexicon = new JMenuItem("Show lexicon entry");
				  miViewLexicon.setActionCommand("VIEW_LEXICON");
				  miViewLexicon.addActionListener(this);
		
		JMenuItem miDeleteAll = new JMenuItem("Delete All Mappings");
        miDeleteAll.setActionCommand("DELETE_ALL");

		
		if( mappings.size() == 0 ) {
			JMenuItem noMappings = new JMenuItem("No mappings for this node.");
			noMappings.setEnabled(false);
			miDeleteAll.setEnabled(false);
			
			mDeleteMappings.add(noMappings);
			
			JMenuItem noMappings2 = new JMenuItem("No mappings for this node.");
			noMappings2.setEnabled(false);
			mProvenance.add(noMappings2);
			
			
		} else {
			
			// build the mappings menu, grouped by matchers
			List<AbstractMatcher> matchers = Core.getInstance().getMatcherInstances();
			Iterator<AbstractMatcher> matcherIter = matchers.iterator();
			while( matcherIter.hasNext() ) {
				AbstractMatcher matcher = matcherIter.next();
				
				int matcherID = matcher.getID();
				
				JMenu mMatcher = new JMenu(matcher.getName() + "(#" + Integer.toString(matcherID) + ")");
				JMenu mMatcherProv = new JMenu(matcher.getName() + "(#" + Integer.toString(matcherID) + ")");
				
				boolean hasMappings = false;
				for( int i = 0; i < mappings.size(); i++ ) {
					MappingData currentData = (MappingData) mappings.get(i).getObject();
					int currentID = currentData.matcherID;
					if( currentID == matcherID ) {
						// we found a mapping of this matcher, add the mapping to the delete menu
						LegacyMapping mapping = mappings.get(i);
						JMenuItem miMapping = new JMenuItem( mapping.toString() );
								  miMapping.setActionCommand( DELETE + Integer.toString(i)); // this is a hack, to be fixed later. - Cosmin (2/14/2010)

						miMapping.addActionListener(this);
						mMatcher.add(miMapping);
						hasMappings = true;
						
						// check for provenance information for this matcher
						Mapping map = ((MappingData)mapping.getObject()).alignment;
						JMenuItem miMappingProvenance;
						if( map.getProvenance() != null ) {
							miMappingProvenance = new JMenuItem( map.getProvenance().length() > provenanceStringMaxLength 
									? map.getProvenance().substring(0, provenanceStringMaxLength) + " ..." 
									: map.getProvenance() );
						} else {
							miMappingProvenance = new JMenuItem("Set provenance ...");
						}
						miMappingProvenance.setActionCommand( SET_PROVENANCE + Integer.toString(i));
						miMappingProvenance.addActionListener(this);
						mMatcherProv.add(miMappingProvenance);
					}
				}
				
				if( hasMappings ) 
				{ 
					mDeleteMappings.add(mMatcher);
					mProvenance.add(mMatcherProv);
				}
				
				
				
			}
		}
		
		add(mDeleteMappings);        
		addSeparator();
		add(mProvenance);
		add(miViewLexicon);
		
		// TODO: add(miDeleteAll);

	}

	public void actionPerformed(ActionEvent e) {

		String actionCommand = e.getActionCommand();
		
		if( actionCommand.equals("DELETE_ALL") && mappings != null) {
			// delete all the mappings associated with the node
			for( int i = 0; i < mappings.size(); i++ ) {
				// maybe popup a confirmation dialog? TODO
				try {
					removeByIndex(i);
				} catch (Exception e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
					UIUtility.displayErrorPane("Could not delete mapping.\n\n"+e1.getMessage(), "Error");
				}
			}
		} else if ( actionCommand.equals("VIEW_LEXICON") && node != null ) {
			try {
				Ontology ont = Core.getInstance().getOntologyByID(node.getObject().ontologyID);
				Lexicon lex = Core.getLexiconStore().getLexicon(ont, LexiconRegistry.ONTOLOGY_LEXICON);
				LexiconLookupPanel lookupPanel = lex.getLookupPanel();
				if( lookupPanel == null ) {
					// we have to create and display it
					Ontology o = Core.getInstance().getOntologyByID( node.getObject().ontologyID );
					lookupPanel = UICore.getUI().getUIMenu().showLexiconLookupPanel(o, LexiconRegistry.ONTOLOGY_LEXICON);
				}
				lookupPanel.doLookup(node.getObject().r);
				UICore.getUI().getTabbedPane().setSelectedComponent(lookupPanel);
			} catch (Exception e1) {
				e1.printStackTrace();
				UIUtility.displayErrorPane("Could not display lexicon lookup panel.\n\n"+e1.getMessage(), "Error");
			}
			
		} else if( actionCommand.length() > DELETE.length() && 
				actionCommand.substring(0, DELETE.length()).equals(DELETE) ) {
			// the action command is the index of the mapping we want to delete
			int index = Integer.parseInt( actionCommand.substring( DELETE.length(), actionCommand.length() ) );
			if( index < 0 || index >= mappings.size() ) {
				// invalid index, do nothing.
				return;
			}
			try {
				removeByIndex(index);
			} catch (Exception e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
				UIUtility.displayErrorPane("Could not delete mapping.\n\n"+e1.getMessage(), "Error");
			}
			
		} else if( actionCommand.length() > SET_PROVENANCE.length() && 
				actionCommand.substring(0, SET_PROVENANCE.length()).equals(SET_PROVENANCE) ) {
			// the action command is the index of the mapping we want to delete
			int index = Integer.parseInt( actionCommand.substring( SET_PROVENANCE.length(), actionCommand.length() ) );
			if( index < 0 || index >= mappings.size() ) {
				// invalid index, do nothing.
				return;
			}
			setMappingProvenance( index );
		}
		
	}
	
	private void removeByIndex( int index ) throws Exception {
		LegacyMapping mapping = mappings.get(index);
		MappingData data = (MappingData) mapping.getObject();
		
		MatchingTask task = Core.getInstance().getMatchingTaskByID( data.matcherID );
		
		
		alignType mappingType = null;
		if( data.mappingType == MappingType.ALIGNING_CLASSES ) mappingType = alignType.aligningClasses;
		else if( data.mappingType == MappingType.ALIGNING_PROPERTIES ) mappingType = alignType.aligningProperties;
		
		assert (mappingType != null); // to protect our code
		
		// we need to get the nodes associated with this mapping
		Ontology o1 = Core.getInstance().getOntologyByID( data.ontologyID );
		Node n1 = null;
		try {
			n1 = o1.getNodefromOntResource( data.r, mappingType );
		} catch (Exception e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		assert (n1 != null);
		
		Ontology o2 = Core.getInstance().getOntologyByID( data.ontologyID2 );
		
		Node n2 = null;
		if( data.alignment != null ) n2 = data.alignment.getEntity2(); 
		else return;
		
		// remove the mapping from the matcher.
		task.matcherResult.removeMapping(n1, n2);
		
		// ok, now that we removed the mapping from the matcher,
		// remove the LegacyMapping from the CanvasGraph 
		
		Canvas2Vertex origin = (Canvas2Vertex) mapping.getOrigin();
		Canvas2Vertex destination = (Canvas2Vertex) mapping.getDestination();
		
		origin.removeOutEdge(mapping);
		destination.removeInEdge(mapping);
		
		Canvas2 canvas = (Canvas2) UICore.getUI().getCanvas();
		CanvasGraph gr = canvas.getMatcherGraph( data.matcherID );
		if( gr != null ) gr.removeEdge( mapping );
		else throw new Exception("Cannot find mapping in the visualization graphs.");
		

		// repaint
		UICore.getUI().redisplayCanvas();
	}
	
	private void setMappingProvenance( int index ) {
		LegacyMapping mapping = mappings.get(index);
		MappingData data = (MappingData) mapping.getObject();
		Mapping m = data.alignment;
		
		String newProvenance = JOptionPane.showInputDialog("Set provenance:", m.getProvenance());
		if( newProvenance != null ) m.setProvenance(newProvenance);
		
	}
	
	
}
