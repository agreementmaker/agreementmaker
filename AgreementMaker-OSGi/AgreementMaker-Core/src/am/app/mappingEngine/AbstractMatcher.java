package am.app.mappingEngine;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;

import javax.swing.SwingWorker;

import am.AMException;
import am.Utility;
import am.app.Core;
import am.app.mappingEngine.Mapping.MappingRelation;
import am.app.mappingEngine.oneToOneSelection.MappingMWBM;
import am.app.mappingEngine.oneToOneSelection.MaxWeightBipartiteMatching;
import am.app.mappingEngine.qualityEvaluation.QualityEvaluationData;
import am.app.mappingEngine.similarityMatrix.AggregativeSparseMatrix;
import am.app.mappingEngine.similarityMatrix.ArraySimilarityMatrix;
import am.app.mappingEngine.similarityMatrix.SimilarityMatrix;
import am.app.mappingEngine.similarityMatrix.SparseMatrix;
import am.app.mappingEngine.threaded.AbstractMatcherRunner;
import am.app.ontology.Node;
import am.app.ontology.Ontology;

import com.hp.hpl.jena.ontology.OntClass;
import com.hp.hpl.jena.util.iterator.ExtendedIterator;

/**
 * transient data are not taken into account while serializing/deserializing the matcher
 * taking transient keyword out of an object means that either you make sure that or you just make it serializable
 * Michele  
 */
public abstract class AbstractMatcher extends SwingWorker<Void, Void> implements MatchingAlgorithm {

	/**
	 * Version identifier for this serializable class
	 */
	private static final long serialVersionUID = 1L;

	/**Unique identifier of the algorithm used in the JTable list as index
	 * if an algorithm gets deleted we have to decrease the index of all others by one
	 * */
	protected int index;
	/**Name of the algorithm, there should be also a final static String in the instance class
	 * in the constructor of the non-abstract class should happen "name = FINALNAME"
	 * */
	protected MatchersRegistry registryEntry;
	/**User mapping should be the only one with this variable equal to false*/
	protected boolean isAutomatic;
	/**True if the algorithm needs additional parameter other than threshold, in this case the developer must develop a JFrame to let the user define them*/
	protected boolean needsParam;
	/**Parameter of this method, if needsParam this item will be generated by the userinterface if not this will be automatically generated with default values*/
	protected transient DefaultMatcherParameters param = new DefaultMatcherParameters();
	/**Developer will have to instantiate this object in the constructor with real parameterpanel for the method which needs param, if a method don't needs param you don't have to touch this attribute*/
	protected transient AbstractMatcherParametersPanel parametersPanel;
	/**True means that AM should show its alignments*/
	protected boolean isShown;
	protected boolean modifiedByUser;
	//protected double threshold;

	/**ANY means any number of relations for source or target*/
	public final static int ANY_INT = Integer.MAX_VALUE;
	//protected int maxSourceAlign;
	//protected int maxTargetAlign;

	/**Contain alignments, NULL if alignment has not been calculated*/
	protected transient Alignment<Mapping> propertiesAlignmentSet;
	protected transient Alignment<Mapping> classesAlignmentSet;

	/**Structure containing similarity values between classes nodes, matrix[source][target]
	 * should not be accessible outside of this class, the system should only be able to access alignments sets
	 * */
	protected SimilarityMatrix classesMatrix;
	/**Structure containing similarity values between classes nodes, matrix[source][target]*/
	protected SimilarityMatrix propertiesMatrix;

	/** The source ontology to be matched. */
	protected transient Ontology sourceOntology;

	/** The target ontology to be matched. */
	protected transient Ontology targetOntology;

	// TODO: Move as many field variables into AbstractParameters as we can.  -- Cosmin. 9/19/2011
	/**If the algo calculates prop alignments*/
	protected boolean alignProp;
	/**If the algo calculates prop alignments*/
	protected boolean alignClass;

	/**
	 * Some algorithms may need other algorithms as input
	 * @deprecated We're moving to MatchingTask based API.  Use {@link #inputTasks}.
	 */
	@Deprecated
	protected transient List<AbstractMatcher> inputMatchers;
	
	protected transient List<MatchingTask> inputTasks;

	
	/**Minum and maximum number of input matchers
	 * a generic matcher which doesn't need any inputs should have 0, 0
	 * */
	protected int minInputMatchers;
	protected int maxInputMatchers;
	/**Variables needed to calculate execution time, executionTime = (end - start)/ unitMeasure, start has to be init in beforeAlign() and end in aferSelect()*/
	protected long start;
	protected long end;
	protected long executionTime;
	/**Keeps info about reference evaluation of the matcher. is null until the algorithm gets evaluated*/
	protected transient ReferenceEvaluationData refEvaluation;
	/**Keeps info about the quality eval of the matcher. null if the algo is not evaluated*/
	protected transient QualityEvaluationData qualEvaluation;

	/**
	 * the matchers combined for example in the LWC matcher can have this set to false, because the partial matchings are not needed. 
	   this parameter is mainly used in batchmode. For the UI has to be set to TRUE. Therefore, the paramter can be set to false, but should always be init to true.
	   Deprecated: With the MatchingTask changes, selection is no longer done in the MatchingAlgorithm. -- Cosmin.
	 *  **/
	@Deprecated
	protected boolean performSelection;

	/** If true, the progress display may not be updated faster than once every 500ms. */
	protected boolean useProgressDelay = true;

	/** A thread group used in threaded execution mode. */
	protected transient ThreadGroup threadGroup;

	protected Properties matcherProperties = new Properties();

	/**
	 * @deprecated Anything to do with selection of mappings has been moved to
	 *             {@link SelectionAlgorithm}.
	 */
	@Deprecated
	public void setPerformSelection(boolean performSelection) {
		this.performSelection = performSelection;
	}
	public void setUseProgressDelay(boolean d ) { useProgressDelay = d; }


	/**This enum is for the matching functions that take nodes as an input.  Because we are comparing two kinds of nodes (classes and properties), we need to know the kind of nodes we are comparing in order to lookup up the input similarities in the corrent matrix */
	public enum alignType implements Serializable {
		aligningClasses("CLASSES"),
		aligningProperties("PROPERTIES"),
		unknown("UNKNOWN");

		private final String value;  

		alignType(String value) {  
			this.value = value;  
		}  

		public static alignType fromValue(String value) {  
			if (value != null) {  
				for (alignType en : values()) {  
					if (en.value.equals(value)) {  
						return en;  
					}  
				}  
			}  

			// you may return a default value  
			return getDefault();  
			// or throw an exception  
			// throw new IllegalArgumentException("Invalid color: " + value);  
		}  

		public String toValue() {  
			return value;  
		}  

		public static alignType getDefault() {  
			return unknown;  
		} 

		private Object readResolve () throws java.io.ObjectStreamException
		{
			if( value == aligningClasses.toValue() ) return aligningClasses;
			if( value == aligningProperties.toValue() ) return aligningProperties;
			return unknown;
		}


	}

	protected transient List<MatchingProgressListener> progressDisplays = new ArrayList<MatchingProgressListener>();  // need to keep track of the dialog in order to close it when we're done.  (there could be a better way to do this, but that's for later)
	protected long stepsTotal; // Used by the ProgressDialog.  This is a rough estimate of the number of steps to be done before we finish the matching.
	protected long stepsDone;  // Used by the ProgressDialog.  This is how many of the total steps we have completed.

	protected String report = "";

	/**
	 * Right now, matchers only produce equivalence relations
	 * If a matcher computes another type of relation, the relation has to be added to the Alignment class as a static variable
	 * and it has to be set as a default relation in the constructor of that matcher.
	 * at the moment a matcher is not allowed to compute different relations for different concepts
	 * in that case a matrix of relation has to be kept within the matcher and the situation has to be managed properly
	 */
	protected MappingRelation relation;


	/**
	 * If this value is set to true, the matcher will run in optimized mode
	 * by matching only the concepts that have not been mapped by the matcher in input
	 * For this reason, if this value is set to true another matcher has to be provided in input to this matcher.
	 * When this value is set to true, the maxNumberInputMatcher is also automatically set to 1 in the setOptimized() method.
	 */
	//protected boolean optimized;
	private int matcherID;

	/**
	 * Used by the updateProgress() method.
	 */
	protected long starttime;
	protected long lastTime = 0;
	protected long lastStepsDone = 0;
	protected int tentativealignments = 0;  // incremental selection?
	protected long timeOfLastUpdate = 0;

	/**
	 * The constructor must be a Nullary Constructor
	 */
	public AbstractMatcher() {  // index and name will be set by the Matcher Factory
		//ALL MATCHERS HAVE TO INVOKE THIS METHOD THROUGH super() EXCEPT UserManualMatcher
		//therefore by modifying something in this method you may also have to modify the UserManualMatcher
		//while all other matchers will automatically inherit the changes
		initializeVariables();
		param = new DefaultMatcherParameters();
	}

	public AbstractMatcher( DefaultMatcherParameters params_new ) {
		initializeVariables();
		param = params_new;
	}

	/**
	 * This function is very important.  It is used by all the constructors to initialize variables when the object is first created.
	 * 
	 * Any matchers that extend AbstractMatcher should override this function with their own if they need to do specific things during the
	 * constructor, but DON'T FORGET TO CALL super.initializeVariables() from their method.
	 * 
	 */
	protected void initializeVariables() {  // TODO: Make this method a PRIVATE method.  If you do that, it should only be called from the constructor. - Cosmin
		//param = new AbstractParameters();
		isAutomatic = true;
		needsParam = false;
		isShown = true;
		modifiedByUser = false;
		performSelection = true;//only in batchmode can be set to false in the internal matchers.
		//threshold = 0.6;
		//maxSourceAlign = 1;
		//maxTargetAlign = 1;
		alignClass = true;
		alignProp = true;
		minInputMatchers = 0;
		maxInputMatchers = Integer.MAX_VALUE;
		relation = MappingRelation.EQUIVALENCE;
		//optimized = false;
		//ALIGNMENTS LIST MUST BE NULL UNTIL THEY ARE CALCULATED
		classesAlignmentSet = null;
		propertiesAlignmentSet = null;

		sourceOntology = Core.getInstance().getSourceOntology(); // moved initialization of sourceOntology to match().
		targetOntology = Core.getInstance().getTargetOntology(); // moved initialization of targetOntology to match().
		inputMatchers = new ArrayList<AbstractMatcher>();

		setName("AbstractMatcher");
		setCategory(MatcherCategory.UNCATEGORIZED);
	}





	//***************************ALL METHODS TO PERFORM THE ALIGNMENT**********************************
	/**
	 * Match(), buildSimilarityMatrix() and select() are the only 3 public methods to be accessed by the system other then get and set methods
	 * All other methods must be protected so that only subclasses may access them (can't be private because subclasses wouldn't be able to use them)
	 * match method is the one which perform the alignment. It also invokes the select() to scan and select matchings
	 * the system sometimes may need to invoke only the select method for example when the user changes threshold of an algorithm, it's not needed to invoke the whole matching process but only select
	 * so at least those two methods must be implemented and public
	 * both methods contains some empty methods to allow developers to add other code if needed
	 * In all cases a developer can override the whole match method or use this one and override the methods inside, or use all methods except for alignTwoNodes() which is the one which perform the real aligment evaluation
	 * and it has to be different
	 * 
	 */

	public void match() throws Exception {

		// setup the Ontologies
		if( sourceOntology == null ) {
			if( Core.getInstance().getSourceOntology() == null ) {
				// no source ontology defined or loaded
				throw new Exception("No source ontology is loaded!");
			} else {
				// the source Ontology is not defined, but a Source ontology is loaded in the Core. Use that.
				sourceOntology = Core.getInstance().getSourceOntology();
			}
		}

		if( targetOntology == null ) {
			if( Core.getInstance().getTargetOntology() == null ) {
				// no target ontology defined or loaded
				throw new Exception("No target ontology is loaded!");
			} else {
				// the target Ontology is not defined as part of this matcher, but a Target ontology is loaded in the Core.  Use that.
				targetOntology = Core.getInstance().getTargetOntology();
			}
		}

		matchStart();
		buildSimilarityMatrices(); // align()
		if(performSelection && !this.isCancelled() ){
			select();	
		}
		matchEnd();
		//System.out.println("Classes alignments found: "+classesAlignmentSet.size());
		//System.out.println("Properties alignments found: "+propertiesAlignmentSet.size());
	}

	/**
	 * Match(), buildSimilarityMatrix() and select() are the only 3 public methods to be accessed by the system other then get and set methods
	 * All other methods must be protected so that only subclasses may access them (can't be private because subclasses wouldn't be able to use them)
	 * match method is the one which perform the alignment. It also invokes the select() to scan and select matchings
	 * the system sometimes may need to invoke only the select method for example when the user changes threshold of an algorithm, it's not needed to invoke the whole matching process but only select
	 * so at least those two methods must be implemented and public
	 * both methods contains some empty methods to allow developers to add other code if needed
	 * In all cases a developer can override the whole match method or use this one and override the methods inside, or use all methods except for alignTwoNodes() which is the one which perform the real aligment evaluation
	 * and it has to be different
	 * It should not be needed often to override the buildSimilarityMatrix(), if you do remember to reinitialize structures everytime at the beginning, and at the end matrices should be filled completely in all cells
	 * It useful to invoke this method instead of the whole matching process while developing a composed matcher which uses other matchers matrices but which doesn't need the alignments sets.
	 * Instead of invoking the whole match() method of each matcher, it can only invoke this one, to avoid the selection process delay.
	 */
	public void buildSimilarityMatrices()throws Exception{
		beforeAlignOperations();//Template method to allow next developer to add code before align
		align();
		afterAlignOperations();//Template method to allow next developer to add code after align
	}


	/**
	 * Match(), buildSimilarityMatrix() and select() are the only 3 public
	 * methods to be accessed by the system other then get and set methods All
	 * other methods must be protected so that only subclasses may access them
	 * (can't be private because subclasses wouldn't be able to use them) match
	 * method is the one which perform the alignment. It also invokes the
	 * select() to scan and select matchings the system sometimes may need to
	 * invoke only the select method for example when the user changes threshold
	 * of an algorithm, it's not needed to invoke the whole matching process but
	 * only select so at least those two methods must be implemented and public
	 * both methods contains some empty methods to allow developers to add other
	 * code if needed In all cases a developer can override the whole match
	 * method or use this one and override the methods inside, or use all
	 * methods except for alignTwoNodes() which is the one which perform the
	 * real aligment evaluation and it has to be different It should not be
	 * needed often to override the select(), in all cases remember to consider
	 * all selection parameters threshold, num relations per source and target.
	 * 
	 * @deprecated A matching algorithm is not able to do mapping selection
	 *             anymore. That functionality has been moved to
	 *             {@link SelectionAlgorithm}.
	 */
	@Deprecated
	public void select() {
		//this method is also invoked everytime the user change threshold or num relation in the table
		beforeSelectionOperations();//Template method to allow next developer to add code after selection
		selectAndSetAlignments();	
		afterSelectionOperations();//Template method to allow next developer to add code after selection
	}

	//***************EMPTY TEMPLATE METHODS TO ALLOW USER TO ADD HIS OWN CODE****************************************

	//reset structures, this is important because anytime we invoke the match() for the secondtime (when we change some values in the table for example)
	//we have to reset all structures. It's the first method that is invoked, when overriding call super.beforeAlignOperations(),
	//IMPORTANT it also takes care of initializing time
	protected void beforeAlignOperations()  throws Exception{
		classesMatrix = null;
		propertiesMatrix = null;
		modifiedByUser = false;
		qualEvaluation = null;
		refEvaluation = null;
	}
	//TEMPLATE METHOD TO ALLOW DEVELOPERS TO ADD CODE: call super when overriding
	protected void afterAlignOperations()  {
		// Setup the ontology IDs of the SimilarityMatrices.
	}
	//RESET ALIGNMENT STRUCTURES,     //TEMPLATE METHOD TO ALLOW DEVELOPERS TO ADD CODE: call super when overriding
	public void beforeSelectionOperations() {
		classesAlignmentSet = null;
		propertiesAlignmentSet = null;
		qualEvaluation = null;
		refEvaluation = null;

		for( MatchingProgressListener mpd : progressDisplays ) {
			mpd.appendToReport("Performing mapping selection ...");
		}
	}
	//TEMPLATE METHOD TO ALLOW DEVELOPERS TO ADD CODE: call super when overriding
	protected void afterSelectionOperations() {
		for( MatchingProgressListener mpd : progressDisplays ) {
			mpd.appendToReport(" Done.\n");
		}
	} 

	//Time calculation, if you override this method remember to call super.afterSelectionOperations()
	public void matchStart() {
		if( isProgressDisplayed() ) {
			setupProgress();  // if we are using the progress dialog, setup the variables
			for( MatchingProgressListener mpd : progressDisplays ) {
				mpd.matchingStarted(this);
			}
		}
		start = System.nanoTime();
		starttime = System.currentTimeMillis();

	}
	//Time calculation, if you override this method remember to call super.afterSelectionOperations()
	public void matchEnd() {
		// TODO: Need to make sure this timing is correct.  - Cosmin ( Dec 17th, 2008 )
		end = System.nanoTime();
		executionTime = (end-start)/1000000; // this time is in milliseconds.
		setSuccesfullReport();	
		if( isProgressDisplayed() ) {
			allStepsDone();
			// the progressDisplays list may be modified upon matchingComplete() calls, so 
			// make a copy of it for iteration purposes.
			List<MatchingProgressListener> displays = new LinkedList<MatchingProgressListener>(progressDisplays);
			for( MatchingProgressListener mpd : displays ) {
				mpd.clearReport();
				mpd.matchingComplete();
			}
		}

	}
	//***************INTERNAL METHODS THAT CAN BE USED BY ANY ABSTRACTMATCHER******************************************

	//***************ALIGNING PHASE*****************//

	protected void align() throws Exception {

		if( sourceOntology == null || targetOntology == null ) return;  // cannot align just one ontology 

		if(alignClass && !this.isCancelled() ) {
			
			if( sourceOntology.getDefinition().largeOntologyMode || 
				targetOntology.getDefinition().largeOntologyMode ) {
				classesMatrix = alignManyClasses();		
			}
			else {
				List<Node> sourceClassList = sourceOntology.getClassesList();
				List<Node> targetClassList = targetOntology.getClassesList();
				classesMatrix = alignClasses(sourceClassList,targetClassList );	
				//classesMatrix.show();
			}
		}
		if(alignProp && !this.isCancelled() ) {
			List<Node> sourcePropList = sourceOntology.getPropertiesList();
			List<Node> targetPropList = targetOntology.getPropertiesList();
			propertiesMatrix = alignProperties(sourcePropList, targetPropList );					
		}

	}

	protected SimilarityMatrix alignProperties( List<Node> sourcePropList, List<Node> targetPropList) throws Exception {
		return alignNodesOneByOne(sourcePropList, targetPropList, alignType.aligningProperties);
	}

	protected SimilarityMatrix alignClasses( List<Node> sourceClassList, List<Node> targetClassList)  throws Exception{
		return alignNodesOneByOne(sourceClassList, targetClassList, alignType.aligningClasses);
	}

	/**
	 * This method is called to match classes when in large ontology mode.
	 * 
	 * @return
	 * @throws Exception
	 */
	protected SimilarityMatrix alignManyClasses() throws Exception {
		AggregativeSparseMatrix matrix = new AggregativeSparseMatrix(sourceOntology, targetOntology, getParam().threshold);
		
		ExtendedIterator<OntClass> sourceClasses = sourceOntology.getModel().listClasses();
		
		int i = 0;
		while( sourceClasses.hasNext() ) {
			OntClass sourceClass = sourceClasses.next();
			ExtendedIterator<OntClass> targetClasses = targetOntology.getModel().listClasses();
			
			int j = 0;
			while( targetClasses.hasNext() ) {
				OntClass targetClass = targetClasses.next();
				Mapping alignment = null;
				if( !this.isCancelled() ) { 
					//alignment = alignTwoNodes(
					//	new JenaClass(sourceClass), new JenaClass(targetClass), alignType.aligningClasses, matrix); }
					// FIXME: Update to work with AgreementMaker-API.
				}
				else { return matrix; }
				
				if(alignment != null && alignment.getSimilarity() >= param.threshold)
					matrix.set(i,j,alignment);
				if( isProgressDisplayed() ) {
					stepDone(); // we have completed one step
					if( alignment != null && alignment.getSimilarity() >= param.threshold ) tentativealignments++; // keep track of possible alignments for progress display
				}
				j++;
			}
			if( isProgressDisplayed() ) updateProgress(); // update the progress dialog, to keep the user informed.
			i++;
		}
		
		return matrix;
	}
	
	protected SimilarityMatrix alignNodesOneByOne( List<Node> sourceList, List<Node> targetList, alignType typeOfNodes) throws Exception {

		if(param.completionMode && inputMatchers != null && inputMatchers.size() > 0){ 
			//run in optimized mode by mapping only concepts that have not been mapped in the input matcher
			if(typeOfNodes.equals(alignType.aligningClasses)){
				return alignUnmappedNodes(sourceList, targetList, inputMatchers.get(0).getClassesMatrix(), inputMatchers.get(0).getClassAlignmentSet(), alignType.aligningClasses);
			}
			else{
				return alignUnmappedNodes(sourceList, targetList, inputMatchers.get(0).getPropertiesMatrix(), inputMatchers.get(0).getPropertyAlignmentSet(), alignType.aligningProperties);
			}
		}

		else if(param.largeOntologyMode ==true){
			//run as a generic matcher who maps all concepts by doing a quadratic number of comparisons
			SimilarityMatrix matrix = new SparseMatrix(sourceOntology, targetOntology, typeOfNodes);
			Node source;
			Node target;
			Mapping alignment = null; //Temp structure to keep sim and relation between two nodes, shouldn't be used for this purpose but is ok
			for(int i = 0; i < sourceList.size(); i++) {
				source = sourceList.get(i);
				for(int j = 0; j < targetList.size(); j++) {
					target = targetList.get(j);

					if( !this.isCancelled() ) { alignment = alignTwoNodes(source, target, typeOfNodes, matrix); }
					else { return matrix; }
					if(alignment != null && alignment.getSimilarity() >= param.threshold)
						matrix.set(i,j,alignment);
					if( isProgressDisplayed() ) {
						stepDone(); // we have completed one step
						if( alignment != null && alignment.getSimilarity() >= param.threshold ) tentativealignments++; // keep track of possible alignments for progress display
					}
				}
				if( isProgressDisplayed() ) updateProgress(); // update the progress dialog, to keep the user informed.
			}
			return matrix;
		}
		else{
			SimilarityMatrix matrix = new ArraySimilarityMatrix(sourceOntology, targetOntology, typeOfNodes);
			Node source;
			Node target;
			//			Mapping alignment = null; //Temp structure to keep sim and relation between two nodes, shouldn't be used for this purpose but is ok


			int availableProcessors = Runtime.getRuntime().availableProcessors() - param.threadedReservedProcessors;
			if( availableProcessors < 1 ) // this should not happen 
				availableProcessors = 1;  // but in case it does, we fix it.

			if( param.threadedExecution && targetList.size() > availableProcessors ) {
				threadGroup = new ThreadGroup(getName());

				// partition the search space into smaller pieces, then assign each partition to a thread
				int sourceStartIndices[] = new int[availableProcessors];
				int sourceEndIndices[]   = new int[availableProcessors];
				int targetStartIndices[] = new int[availableProcessors];
				int targetEndIndices[]   = new int[availableProcessors];

				int sourceRemainder = sourceList.size() % availableProcessors;
				int sourceChunkSize = ( sourceList.size() - sourceRemainder ) / availableProcessors;

				int targetRemainder = targetList.size() % availableProcessors;
				int targetChunkSize = ( targetList.size() - targetRemainder ) / availableProcessors;

				for( int i = 0; i < availableProcessors; i++ ) {
					sourceStartIndices[i] = i*sourceChunkSize;
					sourceEndIndices[i] = sourceStartIndices[i] + sourceChunkSize - 1;

					targetStartIndices[i] = i*targetChunkSize;
					targetEndIndices[i] = targetStartIndices[i] + targetChunkSize - 1;

					if( i == (availableProcessors - 1) ) { 
						sourceEndIndices[i] += sourceRemainder;
						targetEndIndices[i] += targetRemainder;
					}
				}

				//updateProgress();

				// run the stages, spawn threads
				for( int stage = 0; stage < availableProcessors; stage++ ) {

					for( int thread = 0; thread < availableProcessors; thread++ ) {
						int targetIndex = (thread + stage) % availableProcessors;

						AbstractMatcherRunner runner = 
								new AbstractMatcherRunner(sourceList, targetList, 
										sourceStartIndices[thread], sourceEndIndices[thread], targetStartIndices[targetIndex], targetEndIndices[targetIndex], 
										matrix, this, typeOfNodes);

						Thread newThread = new Thread(threadGroup, runner);
						newThread.start();

						if( param.threadedOverlap ) {
							// before spawning another thread, make sure we have room to do it
							while( threadGroup.activeCount() >= availableProcessors ) { 
								try {
									Thread.sleep(500);
								} catch (InterruptedException e) {
									e.printStackTrace();
									this.cancel(true);
								} 
							}
						}
					}

					// wait for the threads at this stage to end, in order to avoid overlaps
					if( !param.threadedOverlap ) {
						while( threadGroup.activeCount() > 0 ) { 
							try {
								Thread.sleep(500);
							} catch (InterruptedException e) {
								e.printStackTrace();
								this.cancel(true);
							} 
						}
					}

				}

				// If running in overlap mode, we have to wait for the threads to end.
				if( param.threadedOverlap ) {
					while( threadGroup.activeCount() > 0 ) { 
						try {
							Thread.sleep(500);
						} catch (InterruptedException e) {
							e.printStackTrace();
							this.cancel(true);
						} 
					}
				}

			} else {
				// non threaded, normal execution
				for(int i = 0; i < sourceList.size(); i++) {
					source = sourceList.get(i);
					for(int j = 0; j < targetList.size(); j++) {
						target = targetList.get(j);

						if( !this.isCancelled() ) {
							Mapping alignment = alignTwoNodes(source, target, typeOfNodes, matrix);

							matrix.set(i,j,alignment);

							if( isProgressDisplayed() ) {
								stepDone(); // we have completed one step
								if( alignment != null && alignment.getSimilarity() >= param.threshold ) {
									tentativealignments++; // keep track of possible alignments for progress display
									//System.out.println(alignment);
								}
								updateProgress();
							}
						}
						else { return matrix; }
					}
					if( isProgressDisplayed() ) updateProgress(); // update the progress dialog, to keep the user informed.
				}
			} 

			return matrix;
		}
	}

	/**
	 * This method implements "Completion Mode", formerly called "OptimizedAbstractMatcher". 
	 */
	protected SimilarityMatrix alignUnmappedNodes( List<Node> sourceList, List<Node> targetList, SimilarityMatrix inputMatrix,
			Alignment<Mapping> inputAlignmentSet, alignType typeOfNodes) throws Exception {

		MappedNodes mappedNodes = new MappedNodes(sourceList, targetList, inputAlignmentSet, param.maxSourceAlign, param.maxTargetAlign);
		SimilarityMatrix matrix = new ArraySimilarityMatrix(sourceOntology, targetOntology, typeOfNodes);
		Node source;
		Node target;
		Mapping alignment; 
		//Mapping inputAlignment;
		for(int i = 0; i < sourceList.size(); i++) {
			source = sourceList.get(i);
			for(int j = 0; j < targetList.size(); j++) {
				target = targetList.get(j);

				if( !this.isCancelled() ) {
					//if both nodes have not been mapped yet enough times
					//we map them regularly
					if(!mappedNodes.isSourceMapped(source) && !mappedNodes.isTargetMapped(target)){
						alignment = alignTwoNodes(source, target, typeOfNodes, matrix); 
					}
					//else we take the alignment that was computed from the previous matcher
					else{
						alignment = inputMatrix.get(i, j);

						//alignment = new Mapping(inputAlignment.getEntity1(), inputAlignment.getEntity2(), inputAlignment.getSimilarity(), inputAlignment.getRelation());
					}
					matrix.set(i,j,alignment);
					if( isProgressDisplayed() ) stepDone(); // we have completed one step
				}
				else { return matrix; }
			}
			if( isProgressDisplayed() ) updateProgress(); // update the progress dialog, to keep the user informed.
		}
		return matrix;
	}

	/**This is the main method that will be always ovverriden by the algorithm which perform the similarity between two generic nodes
	 * @param source the source concept
	 * @param target the target concept
	 * @param typeOfNodes can be alignType.alignClasses or alignType.aligningProperties, and it tells you if you in the alignProperties or classes function
	 * @return the alignment between the two nodes (a, b, sim, relation)
	 * @throws Exception are managed in the doInBackground() method, to interrupt the process to send a message to the user thow new AMException(MESSAGE)
	 */
	protected Mapping alignTwoNodes(Node source, Node target, alignType typeOfNodes, SimilarityMatrix matrix ) throws Exception {
		//TO BE IMPLEMENTED BY THE ALGORITHM, THIS IS JUST A FAKE ABSTRACT METHOD
		double sim;
		MappingRelation rel = MappingRelation.EQUIVALENCE;
		if(source.getLocalName().equals(target.getLocalName())) {
			sim = 1;
		}
		else {
			return null;
		}
		return new Mapping(source, target, sim, rel);
	}

	/**
	 * A parallel version of alignTwoNodes().
	 */
	public Mapping alignTwoNodesParallel(Node source, Node target, alignType typeOfNodes, SimilarityMatrix matrix ) throws Exception {
		// just return the serial implementation.  This method must be implemented by the programmer.
		return alignTwoNodes(source, target, typeOfNodes, matrix);
	}

	//***************SELECTION PHASE*****************//

	protected void selectAndSetAlignments() {
		if(alignClass) {
			classesAlignmentSet = scanMatrix(classesMatrix);
		}
		if(alignProp) {
			propertiesAlignmentSet = scanMatrix(propertiesMatrix);
		}
	}

	protected Alignment<Mapping> scanMatrix(SimilarityMatrix matrix) {
		if( matrix == null ) { // there is no matrix, return empty set
			return new Alignment<Mapping>(sourceOntology.getID(), targetOntology.getID());
		}
		int columns = matrix.getColumns();
		int rows = matrix.getRows();
		// at most each source can be aligned with all targets (columns) it's the same of selecting ANY for source
		int realSourceRelations = Math.min(param.maxSourceAlign, columns);
		// at most each target can be aligned with all sources (rows) it's the same of selecting ANY for target
		int realTargetRelations = Math.min(param.maxTargetAlign, rows);


		if(realSourceRelations == columns && realTargetRelations == rows) { //ANY TO ANY
			return getThemAll(matrix);
		}
		else if(realSourceRelations != columns && realTargetRelations == rows) { //N - ANY that includes also 1-ANY
			//AT LEAST ONE OF THE TWO CONSTRAINTs IS ANY, SO WE JUST HAVE TO PICK ENOUGH MAX VALUES TO SATISFY OTHER CONSTRAINT 
			return scanForMaxValuesRows(matrix, realSourceRelations);
		}
		else if( realSourceRelations == columns && realTargetRelations != rows) {//ANY-N that includes also ANY-1
			//AT LEAST ONE OF THE TWO CONSTRAINTs IS ANY, SO WE JUST HAVE TO PICK ENOUGH MAX VALUES TO SATISFY OTHER CONSTRAINT 
			return scanForMaxValuesColumns(matrix, realTargetRelations);
		}
		else {
			//Both constraints are different from ANY //all cases like 1-1 1-3 or 5-4 or 30-6
			if(realSourceRelations == 1 && realTargetRelations == 1) {//1-1 mapping
				//we can use the hungarian algorithm which provide the optimal solution in polynomial time
				return oneToOneMatching(matrix);
			}
			else { //all cases like 2-2 or 1-3 or 5-4 or 30-6
				//an extension of the stable marriage problem, this is not necesserly optimal but is already more than enough
				return scanWithBothConstraints(matrix, realSourceRelations,realTargetRelations);
			}
		}
	}


	protected Alignment<Mapping> oneToOneMatching(SimilarityMatrix matrix) {
		Alignment<Mapping> aset = new Alignment<Mapping>(sourceOntology.getID(), targetOntology.getID());
		double[][] similarityMatrix = matrix.getCopiedSimilarityMatrix();  // in order of our selection algorithm to be scalable, this has to change! we cannot allocate an NxM matrix if N and M are large! - Cosmin.
		MaxWeightBipartiteMatching<Integer> mwbm = new MaxWeightBipartiteMatching<Integer>(similarityMatrix, param.threshold);
		Collection<MappingMWBM<Integer>> mappings = mwbm.execute();
		Iterator<MappingMWBM<Integer>> it = mappings.iterator();
		Mapping a;
		MappingMWBM<Integer>  m;
		while(it.hasNext()){
			if( this.isCancelled() ) { return null; }
			m = it.next();
			a = matrix.get(m.getSourceNode(), m.getTargetNode());
			if( a != null ) aset.add(a);
		}

		/* CODE FOR THE HUNGARIAN
		 * 		//we can use the hungarian algorithm which provide the optimal solution in polynomial time
		//the hungarian can be used to compute the maxim 1-1 matching or the minimum one, and ofc we need the maximum
		double[][] similarityMatrix = matrix.getSimilarityMatrix(); //hungarian alg needs a double matrix
		double[][] cuttedMatrix = Utility.cutMatrix(similarityMatrix, threshold); //those similarity values lower than the threshold cannot be selected so we remove them from the matrix setting them to 0
		int[][] assignments = HungarianAlgorithm.hgAlgorithm(cuttedMatrix, HungarianAlgorithm.MAX_SUM_TYPE);

		//the array keeps the assignments
		//if the rows are <= cols assignments are [row][col] else they are [col][row]
		for(int i = 0; i < assignments.length; i++) {
			int row = assignments[i][0];
			int col = assignments[i][1];
			if(matrix.getRows() > matrix.getColumns()) {
				row = assignments[i][1];
				col = assignments[i][0];
			}
			if(row != -1 && col != -1) { //if the node was matched
				Alignment a = matrix.get(row, col);
				//i still need to check this even if similarity values have been cutted because the hungarian algorithm can select also values equals to 0 if there is nothing else
				if(a.getSimilarity() >= threshold)
					aset.addAlignment(a);
			}
		}
		 */

		return aset;
	}


	protected Alignment<Mapping> scanForMaxValuesRows(SimilarityMatrix matrix, int numMaxValues) {
		Alignment<Mapping> aset = new Alignment<Mapping>(sourceOntology.getID(), targetOntology.getID());
		Mapping toBeAdded;
		//temp structure to keep the first numMaxValues best alignments for each source
		//when maxRelations are both ANY we could have this structure too big that's why we have checked this case in the previous method
		Mapping[] maxAlignments;
		for(int i = 0; i<matrix.getRows();i++) {
			maxAlignments = matrix.getRowMaxValues(i, numMaxValues);
			//get only the alignments over the threshold
			for(int e = 0;e < maxAlignments.length; e++) { 
				toBeAdded = maxAlignments[e];
				if(toBeAdded != null && toBeAdded.getSimilarity() >= param.threshold) {
					aset.add(toBeAdded);
				}
			}
		}
		return aset;
	}



	protected Alignment<Mapping> scanForMaxValuesColumns(SimilarityMatrix matrix,int numMaxValues) {
		Alignment<Mapping> aset = new Alignment<Mapping>(sourceOntology.getID(), targetOntology.getID());
		Mapping toBeAdded;
		//temp structure to keep the first numMaxValues best alignments for each source
		//when maxRelations are both ANY we could have this structure too big that's why we have checked this case in the previous method
		Mapping[] maxAlignments;
		for(int i = 0; i<matrix.getColumns();i++) {
			maxAlignments = matrix.getColMaxValues(i, numMaxValues);
			//get only the alignments over the threshold
			for(int e = 0;e < maxAlignments.length; e++) { 
				toBeAdded = maxAlignments[e];
				if(toBeAdded != null && toBeAdded.getSimilarity() >= param.threshold) {
					aset.add(toBeAdded);
				}
			}
		}
		return aset;
	}

	/**
	 * Returns all mappings that have a similarity value >= the matcher threshold.
	 * @param matrix Matrix to scan for mappings.
	 * @return Alignment set of mappings. 
	 */
	protected Alignment<Mapping> getThemAll(SimilarityMatrix matrix) {
		Alignment<Mapping> aset = new Alignment<Mapping>(sourceOntology.getID(), targetOntology.getID());
		Mapping currentValue;
		for(int i = 0; i<matrix.getColumns();i++) {
			for(int j = 0; j<matrix.getRows();j++) {		
				currentValue = matrix.get(j,i);
				if(currentValue != null && currentValue.getSimilarity() >= param.threshold)
					aset.add(currentValue);
			}
		}
		return aset;
	}

	protected Alignment<Mapping> scanWithBothConstraints(SimilarityMatrix matrix, int sourceConstraint,int targetConstraint) {


		IntDoublePair fakePair = IntDoublePair.createFakePair();
		int rows = matrix.getRows();
		int cols = matrix.getColumns();

		Alignment<Mapping> aset = new Alignment<Mapping>(sourceOntology.getID(), targetOntology.getID());

		//I need to build a copy of the similarity matrix to work on it, i just need the similarity values
		//and i don't need values higher than threshold so i'll just set them as fake so they won't be selected
		double[][] workingMatrix = new double[rows][cols];
		double sim;
		for(int i = 0; i < rows; i++) {
			for(int j = 0; j < cols; j++) {
				if( matrix.get(i,j) != null ) {
					sim = matrix.get(i,j).getSimilarity();
				} else {
					sim = 0;
				}
				if(sim >= param.threshold)
					workingMatrix[i][j] = sim;
				else workingMatrix[i][j] = IntDoublePair.fake;
			}
		}

		//for each source (row) i need to find the SourceConstraint best values
		//for each maxvalue i need to remember the similarity value and the index of the correspondent column
		//we init it all to (-1,-1)
		IntDoublePair[][] rowsMaxValues = new IntDoublePair[matrix.getRows()][sourceConstraint];
		for(int i= 0; i < rows; i++) {
			for(int j = 0 ; j < sourceConstraint; j++) {
				rowsMaxValues[i][j] = fakePair;
			}
		}

		//for each target (column) i need to find the targetConstraint best values
		//for each maxvalue i need to remember the similarity value and the index of the correspondent column
		//we init it all to (-1,-1)
		IntDoublePair[][] colsMaxValues = new IntDoublePair[matrix.getColumns()][targetConstraint];
		for(int i= 0; i < cols; i++) {
			for(int j = 0 ; j < targetConstraint; j++) {
				colsMaxValues[i][j] = fakePair;
			}
		}

		IntDoublePair maxPairOfRow = null;
		IntDoublePair prevMaxPairOfCol = null;
		IntDoublePair newMaxPairOfCol = null;

		//we must continue until the situation is stable
		//if is a 3-4 mapping it means that we can find at most three alignments for each source and 4 for each target, but not always we can find all
		boolean somethingChanged = true;
		while(somethingChanged) {
			somethingChanged = false;

			for(int i = 0; i < rows; i++) {

				//if I haven't found all best alignments for this row
				if(rowsMaxValues[i][0].isFake()) {

					//I need to get the max of this row, that is ok also for the column
					// so the max of this row must be higher the the max previously selected for that column
					//this do while ends if i find one or if I don't find any so all the cells are fake and the maximum selected is fake too
					do {
						//get the max value for this row and the associated column index
						maxPairOfRow = Utility.getMaxOfRow(workingMatrix, i);

						if(maxPairOfRow.isFake()) {
							break; //all the value of these lines are fake
						}
						else {
							//the minimum of the best values for the column corrisponding to this max
							prevMaxPairOfCol = colsMaxValues[maxPairOfRow.index][0];

							//and i have to set that matrix value to fake so that that row won't select again that value
							workingMatrix[i][maxPairOfRow.index] = IntDoublePair.fake;
						}
					}
					while(maxPairOfRow.value <= prevMaxPairOfCol.value);

					//I don't need the workingMatrix anymore
					//workingMatrix = null;

					//if my value is higher than than the minimum of the best values for this column
					//this value becomes one of the best values and the minimum one is discarded
					//so if the previous while ended because of the while condition not the break one
					if(!maxPairOfRow.isFake()) {

						somethingChanged = true;

						//this value will be one of the best for this column and row, i had to them and update order.
						//prevMaxPairOfCol is not anymore one of the best values for this column
						//i'll switch it with the new one, but i also have to remove it from the best values of his row putting a fake one in it.
						//i also have to modify the matrix so that that row won't select that max again.
						newMaxPairOfCol = new IntDoublePair(i,maxPairOfRow.value);
						colsMaxValues[maxPairOfRow.index][0] = newMaxPairOfCol;
						//reorder that array of best values of this column to have minimum at the beginning
						//we have to move the first element to get the right position
						Utility.adjustOrderPairArray(colsMaxValues[maxPairOfRow.index],0);

						//the max of this row found must be added to the best values for this row, and then order the array,
						rowsMaxValues[i][0] = maxPairOfRow;
						//we have to move the first element to get the right position
						Utility.adjustOrderPairArray(rowsMaxValues[i],0);


						if(!prevMaxPairOfCol.isFake()) {
							//the prev best values has to be removed also from that row best values so i have to find it and set it to fake and reorder
							for(int k = 0; k < rowsMaxValues[prevMaxPairOfCol.index].length; k++) {
								if(rowsMaxValues[prevMaxPairOfCol.index][k].index == maxPairOfRow.index) {
									rowsMaxValues[prevMaxPairOfCol.index][k] = fakePair;
									Utility.adjustOrderPairArray(rowsMaxValues[prevMaxPairOfCol.index], k);
									break;
								}
							}
						}
					}
				}
			}
		}

		/*FOR DEBUGGING
    	for(int i = 0; i < rows; i++) {
    		for(int j = 0; j < cols; j++) {
    			System.out.print(workingMatrix[i][j]+" ");
    		}
    		System.out.println("");
    	}
		 */

		//now we have the alignments into rowMaxValues
		IntDoublePair toBeAdded;
		for(int i = 0; i < rows; i++) {
			for(int j = 0; j < sourceConstraint; j++) {
				toBeAdded = rowsMaxValues[i][j];
				if(!toBeAdded.isFake()) {
					aset.add(matrix.get(i,toBeAdded.index));
				}
			}
		}


		return aset;
	}


	//*****************USER ALIGN METHOD*****************************

	public void addManualAlignments(ArrayList<Mapping> alignments) throws Exception {
		Iterator<Mapping> it = alignments.iterator();
		Mapping al;
		while(it.hasNext()) {
			al = it.next();
			if( al == null ) continue;  // TODO: Figure out why al would be null.
			if(al.getEntity1().isClass() && al.getEntity2().isClass()) {
				if(alignClass) {
					addManualClassAlignment(al) ;
				}
			}
			else if(al.getEntity1().isProp() && al.getEntity2().isProp()) {
				if(alignProp) {
					addManualPropAlignment(al) ;
				}
			}
		}
		select();
		modifiedByUser = true;
	}

	public void addManualClassAlignment(Mapping a) throws Exception {
		if( classesMatrix == null ) throw new Exception("The classMatrix is not initialized."); 
		if( a == null ) throw new Exception("Cannot set a null alignment.");
		addManualAlignment(a, classesMatrix);
	}

	public void addManualPropAlignment(Mapping a) throws Exception {
		if( classesMatrix == null ) throw new Exception("The propertiesMatrix is not initialized."); 
		if( a == null ) throw new Exception("Cannot set a null alignment.");
		addManualAlignment(a, propertiesMatrix);
	}

	public void addManualAlignment(Mapping a, SimilarityMatrix matrix) {
		matrix.set(a.getEntity1().getIndex(), a.getEntity2().getIndex(), a);
	}

	//*****************SET AND GET methods ******************************************
	public AbstractMatcherParametersPanel getParametersPanel() {
		//This method must create and return the AbstractMatcherParameter subclass so that the user can select additional parameters needed by the matcher
		//if the matcher doesn't need any parameter then the attribute needsParameters must be false and this method won't be invoked.
		//REMEMBER to instantiate the panel in this method. Don't initiate the panel in the constructor because the method runs in batch mode the panel is not needed.
		throw new RuntimeException("The method getParametersPanel has to be implemented in the implementing class");
		//You may need to override this method to pass some more information to the panel, in that case instead of initializing the panel in the constructor 
		//you will have to override this method this way: "return new MyParameterPanel(with some more parameters); (see manualCombinationMatcher structure
	}

	public Alignment<Mapping> getAlignment() {
		Alignment<Mapping> aligns = new Alignment<Mapping>(
				sourceOntology.getID(), targetOntology.getID());
		if(areClassesAligned()) {
			aligns.addAll(classesAlignmentSet);
		}
		if(arePropertiesAligned()) {
			aligns.addAll(propertiesAlignmentSet);
		}
		return aligns;
	}

	/**
	 * @deprecated Use {@link AbstractMatcher#getResult()}.
	 */
	@Deprecated
	public Alignment<Mapping> getClassAlignmentSet() {
		return classesAlignmentSet;
	}

	/**
	 * @deprecated Use {@link AbstractMatcher#getResult()}.
	 */
	@Deprecated
	public Alignment<Mapping> getPropertyAlignmentSet() {
		return propertiesAlignmentSet;
	}

	@Deprecated
	public boolean areClassesAligned() {
		return classesAlignmentSet != null;
	}


	@Deprecated
	public boolean arePropertiesAligned() {
		return propertiesAlignmentSet != null;
	}

	@Deprecated
	public boolean isSomethingAligned() {
		return areClassesAligned() || arePropertiesAligned();
	}

	@Deprecated
	public int getNumberClassAlignments() {
		int numAlign = 0;
		if(areClassesAligned()) {
			numAlign += getClassAlignmentSet().size();
		}
		return numAlign;
	}

	@Deprecated
	public int getNumberPropAlignments() {
		int numAlign = 0;
		if(arePropertiesAligned()) {
			numAlign += getPropertyAlignmentSet().size();
		}
		return numAlign;
	}

	@Deprecated
	public int getTotalNumberAlignments() {
		return getNumberClassAlignments()+getNumberPropAlignments();
	}

	public int getIndex() {
		return index;
	}

	public void setIndex(int index) {
		this.index = index;
	}

	@Override
	public String getName() { return getProperty( PropertyKey.NAME ); }
	public void setName(String name) { setProperty(PropertyKey.NAME, name); }

	@Deprecated
	public MatchersRegistry getRegistryEntry() { return registryEntry; }

	@Deprecated
	public void setRegistryEntry(MatchersRegistry name) { this.registryEntry = name; }

	public boolean isAutomatic() { return isAutomatic; }
	public void setAutomatic(boolean isAutomatic) { this.isAutomatic = isAutomatic; }

	public boolean needsParam() { return needsParam; }
	public void setNeedsParam(boolean needsParam) { this.needsParam = needsParam; }

	public boolean isCompletionMode() { return param.completionMode; }

	public DefaultMatcherParameters getParam() {
		return param;
	}

	/**
	 * @param param Cannot be null. If null, we will instantiate a new {@link DefaultMatcherParameters}.
	 */
	public void setParameters(DefaultMatcherParameters param) {
        if(param == null) {
            throw new IllegalArgumentException("Cannot set null parameters.");
        }
        this.param = param;
        this.sourceOntology = param.getSourceOntology();
        this.targetOntology = param.getTargetOntology();
	}

	/**
	 * Use {@link #setParameters(DefaultMatcherParameters) instead. -- Cosmin.
	 */
	 @Deprecated
	 public void setParam(DefaultMatcherParameters param) {
		 setParameters(param);
	 }

	 public int getMaxSourceAlign() {
		 return param.maxSourceAlign;
	 }

	 public void setMaxSourceAlign(int maxSourceAlign) {
		 param.maxSourceAlign = maxSourceAlign;
	 }

	 public int getMaxTargetAlign() {
		 return param.maxTargetAlign;
	 }

	 public void setMaxTargetAlign(int maxTargetAlign) {
		 param.maxTargetAlign = maxTargetAlign;
	 }

	 public int getMinInputMatchers() {
		 return minInputMatchers;
	 }

	 public void setMinInputMatchers(int minInputMatchers) {
		 this.minInputMatchers = minInputMatchers;
	 }

	 public int getMaxInputMatchers() {
		 return maxInputMatchers;
	 }

	 public void setMaxInputMatchers(int maxInputMatchers) {
		 this.maxInputMatchers = maxInputMatchers;
	 }

	 public List<AbstractMatcher> getInputMatchers() {
		 return inputMatchers;
	 }

	 public void addInputTask(MatchingTask t) {
		 if( inputTasks == null ) inputTasks = new LinkedList<MatchingTask>();
		 inputTasks.add(t);
		 // TODO Remove this when the transition to MatchingTask is done.
		 addInputMatcher(t.matchingAlgorithm);
	 }
	 
	 /**
	  * @deprecated Use {@link #addInputTask(MatchingTask)}
	  */
	 public void addInputMatcher(AbstractMatcher a) {
		 if( inputMatchers == null ) inputMatchers = new ArrayList<AbstractMatcher>();
		 inputMatchers.add(a);
	 }

	 public boolean isModifiedByUser() {
		 return modifiedByUser;
	 }

	 public void setModifiedByUser(boolean modifiedByUser) {
		 this.modifiedByUser = modifiedByUser;
	 }

	 public ReferenceEvaluationData getRefEvaluation() {
		 return refEvaluation;
	 }

	 public void setRefEvaluation(ReferenceEvaluationData evaluation) {
		 this.refEvaluation = evaluation;
	 }

	 public boolean isRefEvaluated() {
		 return refEvaluation != null;
	 }

	 public QualityEvaluationData getQualEvaluation() {
		 return qualEvaluation;
	 }

	 public void setQualEvaluation(QualityEvaluationData qualEvaluation) {
		 this.qualEvaluation = qualEvaluation;
	 }

	 public boolean isQualEvaluated() {
		 return qualEvaluation != null;
	 }


	 public boolean isAlignProp() {
		 return alignProp;
	 }

	 public boolean isAlignClass() {
		 return alignClass;
	 }

	 public void setAlignProp(boolean alignProp) {
		 this.alignProp = alignProp;
	 }

	 public void setAlignClass(boolean alignClass) {
		 this.alignClass = alignClass;
	 }

	 public SimilarityMatrix getClassesMatrix() {
		 return classesMatrix;
	 }
	 
	 //TODO is a good idea?
	 public void setClassesMatrix(SimilarityMatrix sm) {
		 this.classesMatrix=sm;
	 }

	 public SimilarityMatrix getPropertiesMatrix() {
		 return propertiesMatrix;
	 }
	 
	//TODO is a good idea?
	 public void setPropertiesMatrix(SimilarityMatrix sm) {
		 this.propertiesMatrix=sm;
	 }

	 public long getExecutionTime() {
		 return executionTime;
	 }

	 public void setExecutionTime(long executionTime) {
		 this.executionTime = executionTime;
	 }

	 public void setInputMatchers(List<AbstractMatcher> inputMatchers) {
		 this.inputMatchers = inputMatchers;
	 }
	 //***********************MEthods used by the interface for some small tasks**************************

	 /**
	  * Matcher details you can override this method to add or change you matcher details if needed, it is only invoked clicking on the button view details in the control panel
	  * @return a string with details of the matchers
	  */
	 public String getDetails() {
		 String s = "";
		 s+= "Matcher: "+getName()+"\n\n";
		 s+= "Brief Description:\n\n";
		 s += getDescriptionString()+"\n";
		 s += "Characteristics\n\n";
		 s += getAttributesString()+"\n";
		 s += "References\n\n";
		 s += getReferenceString()+"\n";
		 return s;
	 }

	 public String getAttributesString() {
		 String s = "";
		 s+= "Additional parameters required: "+Utility.getYesNo(needsParam())+"\n";
		 s+= "Min number of matchers in input: "+Utility.getStringFromNumRelInt(getMinInputMatchers())+"\n";
		 s+= "Max number of matchers in input: "+Utility.getStringFromNumRelInt(getMaxInputMatchers())+"\n";
		 s+= "Performs Classes alignment: "+Utility.getYesNo(isAlignClass())+"\n";
		 s+= "Performs Properties alignment: "+Utility.getYesNo(isAlignProp())+"\n";
		 return s;
	 }
	 /**
	  * All matchers should implement this method to return a description of the algorithm used, the String should finish with \n;
	  * @return
	  */
	 public String getDescriptionString() {
		 return "No description available for this matcher\n";
	 }
	 public String getReferenceString() {
		 return "No references available for this matcher\n";
	 }

	 /**These 3 methods are invoked any time the user select a matcher in the matcherscombobox. Usually developers don't have to override these methods unless their default values are different from these.*/
	 public double getDefaultThreshold() {
		 // TODO Auto-generated method stub
		 return 0.6;
	 }

	 /**These 3 methods are invoked any time the user select a matcher in the matcherscombobox. Usually developers don't have to override these methods unless their default values are different from these.*/
	 public int getDefaultMaxSourceRelations() {
		 // TODO Auto-generated method stub
		 return 1;
	 }

	 /**These 3 methods are invoked any time the user select a matcher in the matcherscombobox. Usually developers don't have to override these methods unless their default values are different from these.*/
	 public int getDefaultMaxTargetRelations() {
		 // TODO Auto-generated method stub
		 return 1;
	 }

	 /**This method is invoked at the end of the matching process if the process successed, to give a feedback to the user. Developers can ovveride it to add additional informations.
	  * Developers can also add a global variable like message that is set dinamically during the matching process to have different type of feedback.
	  * **/

	 public void setSuccesfullReport() {
		 report =  "Matching Process Complete Succesfully!\n\n";
		 if(areClassesAligned()) {
			 report+= "Classes alignments found: "+classesAlignmentSet.size()+"\n";
		 }
		 if(arePropertiesAligned()) {
			 report+= "Properties alignments found: "+propertiesAlignmentSet.size()+"\n";
		 }
		 if(executionTime != 0) {
			 report += "Total execution time (h:m:s:ms): "+Utility.getFormattedTime(executionTime)+"\n";
		 }
	 }

	 public String getReport() {
		 return report;
	 }

	 public void setReport(String report) {
		 this.report = report;
	 }

	 public MappingRelation getRelation() {
		 return relation;
	 }

	 public void setRelation(MappingRelation relation) {
		 this.relation = relation;
	 }     

	 public boolean isOptimized() {
		 return param.completionMode;
	 }

	 public void setOptimized(boolean optimized) {
		 param.completionMode = optimized;
		 if(maxInputMatchers < 1){
			 maxInputMatchers = 1;
		 }
	 }

	 public String getAlignmentsStrings() {
		 //The small arrow must be different from the bigger used in the alignments or the parseReference will identify these lines as alignments
		 String result = "";
		 result+= "Class Alignments: "+classesAlignmentSet.size()+"\n";
		 result += "Source Concept\t ->\tTarget Concept\tSimilarity\tRelation\n\n";
		 result += classesAlignmentSet.getStringList();
		 result+= "Property Alignments: "+propertiesAlignmentSet.size()+"\n";
		 result += "Source Concept\t->\tTarget Concept\tSimilarity\tRelation\n\n";
		 result += propertiesAlignmentSet.getStringList();
		 return result;
	 }

	 /**
	  * More configurable getALignmentsString: you can select whether or not to print classes and properties,
	  * and whether to print localNames or URIs
	  */
	 public String getAlignmentsStrings(boolean classes, boolean properties, boolean URIs) {
		 //The small arrow must be different from the bigger used in the alignments or the parseReference will identify these lines as alignments
		 String result = "";
		 if(classes){
			 result+= "Class Alignments: "+classesAlignmentSet.size()+"\n";
			 result += "Source Concept\t ->\tTarget Concept\tSimilarity\tRelation\tProvenance\n\n";
			 if(URIs == false)
				 result += classesAlignmentSet.getStringList();
			 else result += classesAlignmentSet.getStringList(true);
		 }
		 if(properties){
			 result+= "Property Alignments: "+propertiesAlignmentSet.size()+"\n";
			 result += "Source Concept\t->\tTarget Concept\tSimilarity\tRelation\tProvenance\n\n";
			 result += propertiesAlignmentSet.getStringList();
		 }
		 return result;
	 }

	 /**
	  * TODO: Move this to MatcherResult.  We don't copy AbstractMatchers, but their result. 
	  */
	 public AbstractMatcher copy() throws Exception {
		 AbstractMatcher cloned = this.getClass().newInstance();
		 cloned.setInputMatchers(getInputMatchers());
		 cloned.setParam(getParam());
		 cloned.match();
		 return cloned;

	 }

	 //*************************UTILITY METHODS**************************************
	 public boolean equals(Object o) {
		 if(o instanceof AbstractMatcher) {
			 AbstractMatcher a = (AbstractMatcher)o;
			 return a.getIndex() == this.getIndex();
		 }
		 return false;
	 }

	 public int hashCode() {
		 return index;
	 }


	 //****************** PROGRESS DIALOG METHODS *************************8


	 /**
	  * This function is used by the Progress Dialog, in order to invoke the matcher.
	  * It's just a wrapper for match(). 
	  */
	 public Void doInBackground() throws Exception {
		 try {
			 //without the try catch, the exception got lost in this thread, and we can't debug
			 match();
		 }
		 catch(AMException ex2) {

			 report += "\nUnexpected error.\n";

			 String message = ex2.getMessage();
			 if( !(message == null || message.isEmpty()) ) report += ex2.getMessage() + "\n";
			 else report += ex2.toString();

			 ex2.printStackTrace();
			 this.cancel(true);
			 for( MatchingProgressListener mpd : progressDisplays ) {
				 mpd.appendToReport(report);
				 mpd.matchingComplete(); 
			 }
		 }
		 catch(Exception ex) {
			 report += "\nUnexpected error.\n";

			 String message = ex.getMessage();
			 if( !(message == null || message.isEmpty()) ) report += ex.getMessage() + "\n";
			 else report += ex.toString();

			 ex.printStackTrace();
			 this.cancel(true);
			 for( MatchingProgressListener mpd : progressDisplays ) {
				 mpd.appendToReport(report);
				 mpd.matchingComplete(); 
			 }
		 }
		 return null;
	 }

	 /**
	  * Function called by the worker thread when the matcher finishes the algorithm.
	  */
	 /*public void done() {
    	if( isProgressDisplayed() ) progressDisplay.matchingComplete();  // when we're done, close the progress dialog
    }*/

	 /**
	  * Need to keep track of the progress dialog we have because right now, there is no button to close it, so we must make it close automatically.
	  * @param p
	  */
	 public void addProgressDisplay( MatchingProgressListener p ) {
		 if( p == null )
			 throw new RuntimeException("Cannot accept a null progress listener.");
		 
		 progressDisplays.add(p);
		 addPropertyChangeListener(p);
	 }

	 public void removeProgressDisplay( MatchingProgressListener p ) {
		 if( p == null )
			 throw new RuntimeException("Cannot remove a null progress listener.");
		 
		 progressDisplays.remove(p);
		 removePropertyChangeListener(p);
	 }

	 public MatchingProgressListener getProgressDisplay(int index) {
		 return progressDisplays.get(index);
	 }

	 public List<MatchingProgressListener> getProgressDisplays() { return progressDisplays; }

	 /**
	  * This method sets up stepsDone and stepsTotal.  Override this method if you have a special way of computing the values.
	  * ( If you override this method, it's likely that you will also need to override alignNodesOneByOne(), because it calls stepDone() and updateProgress() ).
	  * @author Cosmin Stroe @date Dec 17, 2008
	  */
	 protected void setupProgress() {
		 stepsDone = 0;
		 stepsTotal = 0;  // total number
		 if( alignClass ) {
			 if( sourceOntology.getDefinition().largeOntologyMode ||
				 targetOntology.getDefinition().largeOntologyMode ) {
				 int n = sourceOntology.getModel().listClasses().toList().size();
				 int m = targetOntology.getModel().listClasses().toList().size();
				 stepsTotal += n*m;  // total number of comparisons between the class nodes
			 }
			 else {
				 int n = sourceOntology.getClassesList().size();
				 int m = targetOntology.getClassesList().size();
				 stepsTotal += n*m;  // total number of comparisons between the class nodes
			 }
		 }

		 if( alignProp ) {
			 int n = sourceOntology.getPropertiesList().size();
			 int m = targetOntology.getPropertiesList().size();
			 stepsTotal += n*m; // total number of comparisons between the properties nodes
		 }

		 // we have computed stepsTotal, and initialized stepsDone to 0.
		 setProgress(0);
	 }

	 /**
	  * We have just completed one step of the total number of steps.
	  * 
	  * Remember, stepsDone is used in conjunction with stepsTotal, in order to get 
	  * an idea of how much of the total task we have done ( % done = stepsDone / stepsTotal * 100 ).
	  * 
	  *  @author Cosmin Stroe @date Dec 17, 2008
	  */
	 public void stepDone() {
		 stepsDone++;
	 }


	 /**
	  * Update the Progress Dialog with the current progress.
	  * 
	  *  @author Cosmin Stroe @date Dec 17, 2008
	  *  @author Cosmin Stroe @date Oct 1, 2010 @comment Updated to display estimated total time and estimated time left.  
	  */	
	 public void updateProgress() {

		 long currentTime = System.currentTimeMillis();
		 if( !useProgressDelay || currentTime - timeOfLastUpdate > 500 ) {
			 timeOfLastUpdate = currentTime;
			 long elapsedTime = currentTime - lastTime;
			 long elapsedSteps = stepsDone - lastStepsDone;
			 long totalelapsed = currentTime - starttime; // elapsed time since the start of the algorithm

			 long estimatedDuration = elapsedSteps == 0 ? 0 : elapsedTime * ( stepsTotal / elapsedSteps );
			 long estimatedtimeleft = stepsDone == 0 ? 0 : ((stepsTotal - stepsDone) * totalelapsed) / stepsDone;   

			 String formattedTime = Utility.getFormattedTime(estimatedDuration);

			 float percent = stepsTotal == 0 ? 0f : ((float)stepsDone / (float)stepsTotal);

			 for( MatchingProgressListener mpd : progressDisplays ) {
				 mpd.clearReport();
				 mpd.appendToReport( "Percentage done: " + Float.toString(percent* 100.0f)+ "%\n" +
						 "Current duration: " + Utility.getFormattedTime(totalelapsed) + "\n" +  
						 "Time left ~: " + Utility.getFormattedTime(estimatedtimeleft) + "\n" +
						 "Total Duration ~: " + formattedTime + "\n" +
						 "Mappings >= threshold: " + tentativealignments + "\n");
			 }

			 lastTime = currentTime;
			 lastStepsDone = stepsDone;

			 Float p_f = new Float(percent * 100.0f);
			 int p = p_f.intValue();

			 // some error checking
			 if( p > 100 && p > 0 ) { p = 100; }
			 if( p < 0 ) { p = 0; }
			 setProgress(p);  // this function does the actual work ( via Swingworker, which uses the PropertyChangeListener )
		 } else if( stepsDone == stepsTotal ) {
			 // we're done here.
			 setProgress(100);
		 }

	 }

	 /**
	  * Should only be called while the matcher is still runnning.
	  * @return The time in milliseconds that the matcher has been running.
	  */
	 public long getRunningTime() {
		 return System.currentTimeMillis() - lastTime;
	 }

	 /**
	  * If the matcher implemented by a developer doesn't take care of the progress
	  * for example it overrides the align method and doesn't write any code to increase steps
	  * in that case we have to force the progress to be 100% at the end
	  * It is used into matchEnd() method.
	  * For the same reason setupProgress is inside matchStart();
	  * Assuming that a developer shouldn't change match() or matchStart() or matchEnd()
	  */

	 protected void allStepsDone() {
		 if( stepsTotal <= 0 ) stepsTotal = 1; // avoid division by 0;
		 if(stepsDone != stepsTotal) {
			 stepsDone = stepsTotal;
			 updateProgress();
		 }
	 }

	 /**
	  * If a matcher invokes the match() method of another matcher internally, the internal matcher 
	  * won't have the progressDisplay, and the globalstaticvariable may be still true
	  * so we have to check both conditions
	  */
	 public boolean isProgressDisplayed() {
		 return progressDisplays.size() > 0;  // don't need to check for the global static variable, since if it's false, we should never have to call this function
	 }

	 public void setPropertiesAlignmentSet(Alignment<Mapping> propertiesAlignmentSet) {
		 this.propertiesAlignmentSet = propertiesAlignmentSet;
	 }

	 public void setCategory( MatcherCategory category ) {
		 setProperty(PropertyKey.CATEGORY, category.name());
	 }

	 public MatcherCategory getCategory() {
		 String categoryString = getProperty(PropertyKey.CATEGORY);
		 return MatcherCategory.valueOf(categoryString);
	 }

	 public void setClassesAlignmentSet(Alignment<Mapping> classesAlignmentSet) {
		 this.classesAlignmentSet = classesAlignmentSet;
	 }

	 public void setID(int nextMatcherID) { matcherID = nextMatcherID; }
	 public int  getID()                  { return matcherID; }

	 /**
	  * this method removes any mappings between these two nodes
	  * 
	  * @param source The source concept.
	  * @param target The target concept.  Must be the same type of concept as the source.
	  * 
	  * @deprecated Belongs in {@link MatcherResult}.
	  */
	 @Deprecated
	 public Mapping getMapping(Node source, Node target) {

		 if( (source.isClass() && target.isProp()) || (source.isProp() && target.isClass()) ) {
			 // cannot have mappings between non matching types of concepts
			 return null;
		 }

		 if( source.isClass() )	return classesAlignmentSet.contains(source, target);
		 if( source.isProp() ) return propertiesAlignmentSet.contains(source, target);
		 return null;
	 }



	 /***************** Ontology methods **************************/

	 public Ontology getSourceOntology() { return sourceOntology; }
	 public Ontology getTargetOntology() { return targetOntology; }

	 public void setSourceOntology( Ontology s ) { sourceOntology = s; }
	 public void setTargetOntology( Ontology t ) { targetOntology = t; }
	 public void setOntologies( Ontology source, Ontology target ) { sourceOntology = source; targetOntology = target; } // convenience function


	 /** ****************** Serialization methods *******************/

	 /**
	  * readObject: gets the state of the object.
	  * @author michele
	  */
	 public static AbstractMatcher readObject(ObjectInputStream in) throws ClassNotFoundException, IOException {
		 AbstractMatcher thisClass = (AbstractMatcher) in.readObject();
		 in.close();
		 return thisClass;
	 }

	 /**
	  * writeObject: saves the state of the object.
	  * @author michele
	  */
	 public void writeObject(ObjectOutputStream out) throws IOException {
		 out.writeObject(this);
		 out.close();
	 }


	 /***********************************************************************************************
	  ************************************* MATCHER FEATURES ****************************************
	  ***********************************************************************************************/

	 // List of features supported by this matcher.
	 protected List<MatcherFeature> supportedFeatures = null;

	 /**
	  * The result of this matcher.
	  * 
	  * @see {@link #getResult()}, {@link #setResult(MatcherResult)}.
	  */
	 protected MatcherResult matcherResult;

	 /**
	  * Determine if a feature is supported by a specific matcher.
	  * These features must be setup in the constructor.
	  * @param f Feature to check for.
	  * @return true if feature is supported, false otherwise.
	  */
	 public boolean supportsFeature( MatcherFeature f ) { 
		 if( supportedFeatures != null ) return supportedFeatures.contains(f); 
		 return false;
	 }

	 protected void addFeature ( MatcherFeature f ) { 
		 if( !supportsFeature(f) ) { 
			 if( supportedFeatures == null ) supportedFeatures = new ArrayList<MatcherFeature>(); 
			 supportedFeatures.add(f); 
		 }
	 }
	 

	 public synchronized void saveThreadResult(int source, int target, Mapping mapping, SimilarityMatrix matrix ) {
		 matrix.set(source, target, mapping);
	 }




	 @Override
	 public String toString() {
		 return getName();
	 }

	 @Override
	 public MatcherResult getResult() {
		 if( this.matcherResult == null ) {
			 // TODO: Fix this to use the correct constructor from MatcherResult.
			 this.matcherResult = new MatcherResult(this);
		 }
		 return matcherResult;
	 }

	 @Override
	 public void setResult(MatcherResult result) {
		 this.matcherResult = result;
	 }

	 public String getProperty(PropertyKey key) {
		 return matcherProperties.getProperty(key.name());
	 }

	 protected void setProperty(PropertyKey key, String value) {
		 matcherProperties.setProperty(key.name(), value);
	 }

	 /**
	  * Keys used for matcher properties.
	  * 
	  * @see {@link #getProperty}, {@link #setProperty}
	  */
	 public static enum PropertyKey {
		 CATEGORY,
		 NAME;
	 }

	 /**
	  * This enumeration defines categories for matchers.
	  * Used for presentation purposes.
	  * @author Cosmin Stroe
	  * @date Monday, December 13th, 2010.
	  */
	 public enum MatcherCategory {
		 SYNTACTIC,		// Syntactic Matchers.
		 STRUCTURAL,		// Structural Matchers.
		 LEXICAL,		// Matchers that use a dictionary.
		 COMBINATION,    // Matchers that produce a combination of other matchers. 
		 HYBRID,			// Matchers that consider many features together.
		 UTILITY, 		// Utility matcher,
		 INSTANCE,		// Instance matcher
		 USER,			// User matchers
		 UNCATEGORIZED;	// Matchers that have not been categorized.
	 }
}
